--- a/ic2/core/network/DataEncoder.java
+++ b/ic2/core/network/DataEncoder.java
@@ -9,9 +9,12 @@
 import ic2.core.IC2;
 import ic2.core.block.comp.TileEntityComponent;
 import ic2.core.block.invslot.InvSlot;
+import ic2.core.network.GrowingBuffer;
 import ic2.core.util.StackUtil;
 import ic2.core.util.Tuple;
 import ic2.core.util.Util;
+import java.io.DataInput;
+import java.io.DataOutput;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -42,704 +45,760 @@
 import net.minecraftforge.fluids.FluidTank;
 
 public final class DataEncoder {
-   private static final Map<Class<?>, DataEncoder.EncodedType> classToTypeCache = Collections.<Class<?>, DataEncoder.EncodedType>synchronizedMap(new IdentityHashMap());
-   private static final Map<Class<?>, INetworkCustomEncoder> classToAddonType = Collections.<Class<?>, INetworkCustomEncoder>synchronizedMap(new IdentityHashMap());
+   private static final Map<Class<?>, EncodedType> classToTypeCache = Collections.synchronizedMap(new IdentityHashMap());
+   private static final Map<Class<?>, INetworkCustomEncoder> classToAddonType = Collections.synchronizedMap(new IdentityHashMap());
 
    public static void encode(GrowingBuffer os, Object o) throws IOException {
       try {
-         encode(os, o, true);
-      } catch (IllegalArgumentException illegalargumentexception) {
-         IC2.platform.displayError(illegalargumentexception, "An unknown data type was attempted to be encoded for sending through\nmultiplayer.\nThis could happen due to a bug.");
-      }
-
+         DataEncoder.encode(os, o, true);
+      }
+      catch (IllegalArgumentException e) {
+         IC2.platform.displayError(e, "An unknown data type was attempted to be encoded for sending through\nmultiplayer.\nThis could happen due to a bug.", new Object[0]);
+      }
    }
 
    public static void encode(IGrowingBuffer os, Object o, boolean withType) throws IOException {
-      DataEncoder.EncodedType dataencoder$encodedtype = typeFromObject(o);
+      EncodedType type = DataEncoder.typeFromObject(o);
       if (withType) {
-         os.writeByte(idFromType(dataencoder$encodedtype));
+         os.writeByte(DataEncoder.idFromType(type));
       }
-
-      switch(dataencoder$encodedtype) {
-      case Addon:
-      case UnSafeAddon:
-         assert o != null;
-
-         INetworkCustomEncoder inetworkcustomencoder = classToAddonType.get(o.getClass());
-         if (inetworkcustomencoder == null) {
-            throw new IllegalStateException("Cannot encode an object without an encoder! Type was " + o.getClass());
+      return;
+      /*switch (type) {
+         case Addon:
+         case UnSafeAddon: {
+            assert (o != null);
+            INetworkCustomEncoder ince = classToAddonType.get(o.getClass());
+            if (ince == null) {
+               throw new IllegalStateException("Cannot encode an object without an encoder! Type was " + o.getClass());
+            }
+            os.writeString(o.getClass().getName());
+            ince.encode(os, o);
+            break;
          }
-
-         os.writeString(o.getClass().getName());
-         inetworkcustomencoder.encode(os, o);
-         break;
-      case Array:
-         Class<?> oclass = o.getClass().getComponentType();
-         int j = Array.getLength(o);
-         if (oclass == Object.class && j > 0) {
-            boolean flag = false;
-            Class<?> oclass1 = null;
-
-            label203:
-            for(int k = 0; k < j; ++k) {
-               Object object = Array.get(o, k);
-               if (oclass1 == null) {
-                  if (object instanceof Enum) {
-                     oclass1 = ((Enum)object).getDeclaringClass();
-                     flag = true;
-                  } else if (object != null) {
-                     oclass1 = object.getClass();
-
-                     assert oclass1 != Object.class;
+         case Array: {
+            Object value;
+            int i;
+            Class<?> componentClass = o.getClass().getComponentType();
+            int len = Array.getLength(o);
+            if (componentClass == Object.class && len > 0) {
+               boolean isEnum = false;
+               Class<?> target = null;
+               block40: for (i = 0; i < len; ++i) {
+                  value = Array.get(o, i);
+                  if (target == null) {
+                     if (value instanceof Enum) {
+                        target = ((Enum)value).getDeclaringClass();
+                        isEnum = true;
+                        continue;
+                     }
+                     if (value == null) continue;
+                     target = value.getClass();
+                     assert (target != Object.class);
+                     continue;
                   }
-               } else if (object != null) {
-                  Class<?> oclass2 = object.getClass();
-                  if (oclass2 != oclass1 && !oclass1.isAssignableFrom(oclass2)) {
-                     if (flag || object instanceof Enum) {
-                        throw new IllegalArgumentException("Array of mixed enum entries");
-                     }
-
-                     while((oclass1 = oclass1.getSuperclass()) != Object.class) {
-                        if (oclass1.isAssignableFrom(oclass2)) {
-                           continue label203;
-                        }
-                     }
-
-                     ++k;
-
-                     while(k < j) {
-                        if (Array.get(o, k) instanceof Enum) {
+                  if (value != null) {
+                     Class<?> valueClass = value.getClass();
+                     if (valueClass != target && !target.isAssignableFrom(valueClass)) {
+                        if (isEnum || value instanceof Enum) {
                            throw new IllegalArgumentException("Array of mixed enum entries");
                         }
-
-                        ++k;
+                        while ((target = target.getSuperclass()) != Object.class) {
+                           if (!target.isAssignableFrom(valueClass)) continue;
+                           continue block40;
+                        }
+                        ++i;
+                        while (i < len) {
+                           if (Array.get(o, i) instanceof Enum) {
+                              throw new IllegalArgumentException("Array of mixed enum entries");
+                           }
+                           ++i;
+                        }
+                        target = Object.class;
+                        break;
                      }
-
-                     oclass1 = Object.class;
-                     break;
-                  } else {
-                     assert flag == (object instanceof Enum);
+                     assert (isEnum == value instanceof Enum);
+                     continue;
                   }
-               } else if (flag) {
+                  if (!isEnum) continue;
                   throw new IllegalArgumentException("Enum array with null entry");
                }
-            }
-
-            oclass = oclass1;
-         }
-
-         DataEncoder.EncodedType dataencoder$encodedtype1 = typeFromClass(oclass);
-         os.writeByte(idFromType(dataencoder$encodedtype1));
-         os.writeBoolean(oclass.isPrimitive());
-         if (dataencoder$encodedtype1 == DataEncoder.EncodedType.Addon || dataencoder$encodedtype1 == DataEncoder.EncodedType.UnSafeAddon || dataencoder$encodedtype1 == DataEncoder.EncodedType.Enum) {
-            os.writeString(oclass.getName());
-         }
-
-         os.writeVarInt(j);
-         boolean flag1 = false;
-
-         for(int l = 0; l < j; ++l) {
-            Object object1 = Array.get(o, l);
-            if (object1 == null || typeFromClass(object1.getClass()) != dataencoder$encodedtype1) {
-               flag1 = true;
-               break;
-            }
-         }
-
-         os.writeBoolean(flag1);
-
-         for(int i1 = 0; i1 < j; ++i1) {
-            encode(os, Array.get(o, i1), flag1);
-         }
-         break;
-      case Block:
-         encode(os, Util.getName((Block)o), false);
-         break;
-      case BlockPos:
-         BlockPos blockpos = (BlockPos)o;
-         os.writeInt(blockpos.getX());
-         os.writeInt(blockpos.getY());
-         os.writeInt(blockpos.getZ());
-         break;
-      case Boolean:
-         os.writeBoolean(((Boolean)o).booleanValue());
-         break;
-      case Byte:
-         os.writeByte(((Byte)o).byteValue());
-         break;
-      case Character:
-         os.writeChar(((Character)o).charValue());
-         break;
-      case ChunkPos:
-         ChunkPos chunkpos = (ChunkPos)o;
-         os.writeInt(chunkpos.x);
-         os.writeInt(chunkpos.z);
-         break;
-      case Collection:
-         encode(os, ((Collection)o).toArray(), false);
-         break;
-      case Component:
-         NBTTagCompound nbttagcompound = ((TileEntityComponent)o).writeToNbt();
-         encode(os, nbttagcompound == null ? new NBTTagCompound() : nbttagcompound, false);
-         break;
-      case CropCard:
-         CropCard cropcard = (CropCard)o;
-         os.writeString(cropcard.getOwner());
-         os.writeString(cropcard.getId());
-         break;
-      case Double:
-         os.writeDouble(((Double)o).doubleValue());
-         break;
-      case ElectrolyzerRecipe:
-         IElectrolyzerRecipeManager.ElectrolyzerRecipe ielectrolyzerrecipemanager$electrolyzerrecipe = (IElectrolyzerRecipeManager.ElectrolyzerRecipe)o;
-         os.writeInt(ielectrolyzerrecipemanager$electrolyzerrecipe.inputAmount);
-         os.writeInt(ielectrolyzerrecipemanager$electrolyzerrecipe.EUaTick);
-         os.writeInt(ielectrolyzerrecipemanager$electrolyzerrecipe.ticksNeeded);
-         IElectrolyzerRecipeManager.ElectrolyzerOutput[] aielectrolyzerrecipemanager$electrolyzeroutput = ielectrolyzerrecipemanager$electrolyzerrecipe.outputs;
-         os.writeByte(aielectrolyzerrecipemanager$electrolyzeroutput.length);
-
-         for(IElectrolyzerRecipeManager.ElectrolyzerOutput ielectrolyzerrecipemanager$electrolyzeroutput : aielectrolyzerrecipemanager$electrolyzeroutput) {
-            os.writeString(ielectrolyzerrecipemanager$electrolyzeroutput.fluidName);
-            os.writeInt(ielectrolyzerrecipemanager$electrolyzeroutput.fluidAmount);
-            os.writeByte(ielectrolyzerrecipemanager$electrolyzeroutput.tankDirection.getIndex());
-         }
-
-         return;
-      case Enchantment:
-         encode(os, Enchantment.REGISTRY.getNameForObject((Enchantment)o), false);
-         break;
-      case Enum:
-         os.writeVarInt(((Enum)o).ordinal());
-         break;
-      case Float:
-         os.writeFloat(((Float)o).floatValue());
-         break;
-      case Fluid:
-         os.writeString(((Fluid)o).getName());
-         break;
-      case FluidStack:
-         FluidStack fluidstack = (FluidStack)o;
-         encode(os, fluidstack.getFluid(), false);
-         os.writeInt(fluidstack.amount);
-         encode(os, fluidstack.tag, true);
-         break;
-      case FluidTank:
-         FluidTank fluidtank = (FluidTank)o;
-         encode(os, fluidtank.getFluid(), true);
-         os.writeInt(fluidtank.getCapacity());
-         break;
-      case GameProfile:
-         GameProfile gameprofile = (GameProfile)o;
-         encode(os, gameprofile.getId(), true);
-         os.writeString(gameprofile.getName());
-         break;
-      case Integer:
-         os.writeInt(((Integer)o).intValue());
-         break;
-      case InvSlot:
-         InvSlot invslot = (InvSlot)o;
-         ItemStack[] aitemstack = new ItemStack[invslot.size()];
-
-         for(int i = 0; i < invslot.size(); ++i) {
-            aitemstack[i] = invslot.get(i);
-         }
-
-         encode(os, aitemstack, false);
-         break;
-      case Item:
-         encode(os, Util.getName((Item)o), false);
-         break;
-      case ItemStack:
-         ItemStack itemstack = (ItemStack)o;
-         if (StackUtil.isEmpty(itemstack)) {
-            os.writeByte(0);
-         } else {
-            os.writeByte(StackUtil.getSize(itemstack));
-            encode(os, itemstack.getItem(), false);
-            os.writeShort(itemstack.getItemDamage());
-            encode(os, itemstack.getTagCompound(), true);
-         }
-         break;
-      case Long:
-         os.writeLong(((Long)o).longValue());
-         break;
-      case NBTTagCompound:
-         CompressedStreamTools.write((NBTTagCompound)o, os);
-         break;
-      case Null:
-         if (!withType) {
+               componentClass = target;
+            }
+            EncodedType componentType = DataEncoder.typeFromClass(componentClass);
+            os.writeByte(DataEncoder.idFromType(componentType));
+            os.writeBoolean(componentClass.isPrimitive());
+            if (componentType == EncodedType.Addon || componentType == EncodedType.UnSafeAddon || componentType == EncodedType.Enum) {
+               os.writeString(componentClass.getName());
+            }
+            os.writeVarInt(len);
+            boolean anyTypeMismatch = false;
+            for (i = 0; i < len; ++i) {
+               value = Array.get(o, i);
+               if (value != null && DataEncoder.typeFromClass(value.getClass()) == componentType) continue;
+               anyTypeMismatch = true;
+               break;
+            }
+            os.writeBoolean(anyTypeMismatch);
+            for (i = 0; i < len; ++i) {
+               DataEncoder.encode(os, Array.get(o, i), anyTypeMismatch);
+            }
+            break;
+         }
+         case Block: {
+            DataEncoder.encode(os, Util.getName((Block)o), false);
+            break;
+         }
+         case BlockPos: {
+            BlockPos pos = (BlockPos)o;
+            os.writeInt(pos.getX());
+            os.writeInt(pos.getY());
+            os.writeInt(pos.getZ());
+            break;
+         }
+         case Boolean: {
+            os.writeBoolean((Boolean)o);
+            break;
+         }
+         case Byte: {
+            os.writeByte(((Byte)o).byteValue());
+            break;
+         }
+         case Character: {
+            os.writeChar(((Character)o).charValue());
+            break;
+         }
+         case ChunkPos: {
+            ChunkPos pos = (ChunkPos)o;
+            os.writeInt(pos.x);
+            os.writeInt(pos.z);
+            break;
+         }
+         case Collection: {
+            DataEncoder.encode(os, ((Collection)o).toArray(), false);
+            break;
+         }
+         case Component: {
+            NBTTagCompound nbt = ((TileEntityComponent)o).writeToNbt();
+            DataEncoder.encode(os, nbt == null ? new NBTTagCompound() : nbt, false);
+            break;
+         }
+         case CropCard: {
+            CropCard cropCard = (CropCard)o;
+            os.writeString(cropCard.getOwner());
+            os.writeString(cropCard.getId());
+            break;
+         }
+         case Double: {
+            os.writeDouble((Double)o);
+            break;
+         }
+         case ElectrolyzerRecipe: {
+            IElectrolyzerRecipeManager.ElectrolyzerRecipe recipe = (IElectrolyzerRecipeManager.ElectrolyzerRecipe)o;
+            os.writeInt(recipe.inputAmount);
+            os.writeInt(recipe.EUaTick);
+            os.writeInt(recipe.ticksNeeded);
+            IElectrolyzerRecipeManager.ElectrolyzerOutput[] outputs = recipe.outputs;
+            os.writeByte(outputs.length);
+            for (IElectrolyzerRecipeManager.ElectrolyzerOutput output : outputs) {
+               os.writeString(output.fluidName);
+               os.writeInt(output.fluidAmount);
+               os.writeByte(output.tankDirection.getIndex());
+            }
+            break;
+         }
+         case Enchantment: {
+            DataEncoder.encode(os, Enchantment.REGISTRY.getNameForObject(((Enchantment)o)), false);
+            break;
+         }
+         case Enum: {
+            os.writeVarInt(((Enum)o).ordinal());
+            break;
+         }
+         case Float: {
+            os.writeFloat(((Float)o).floatValue());
+            break;
+         }
+         case Fluid: {
+            os.writeString(((Fluid)o).getName());
+            break;
+         }
+         case FluidStack: {
+            FluidStack fs = (FluidStack)o;
+            DataEncoder.encode(os, fs.getFluid(), false);
+            os.writeInt(fs.amount);
+            DataEncoder.encode(os, fs.tag, true);
+            break;
+         }
+         case FluidTank: {
+            FluidTank tank = (FluidTank)o;
+            DataEncoder.encode(os, tank.getFluid(), true);
+            os.writeInt(tank.getCapacity());
+            break;
+         }
+         case GameProfile: {
+            GameProfile gp = (GameProfile)o;
+            DataEncoder.encode(os, gp.getId(), true);
+            os.writeString(gp.getName());
+            break;
+         }
+         case Integer: {
+            os.writeInt((Integer)o);
+            break;
+         }
+         case InvSlot: {
+            InvSlot slot = (InvSlot)o;
+            ItemStack[] contents = new ItemStack[slot.size()];
+            for (int i = 0; i < slot.size(); ++i) {
+               contents[i] = slot.get(i);
+            }
+            DataEncoder.encode(os, contents, false);
+            break;
+         }
+         case Item: {
+            DataEncoder.encode(os, Util.getName((Item)o), false);
+            break;
+         }
+         case ItemStack: {
+            ItemStack stack = (ItemStack)o;
+            if (StackUtil.isEmpty(stack)) {
+               os.writeByte(0);
+               break;
+            }
+            os.writeByte(StackUtil.getSize(stack));
+            DataEncoder.encode(os, stack.getItem(), false);
+            os.writeShort(stack.getItemDamage());
+            DataEncoder.encode(os, stack.getTagCompound(), true);
+            break;
+         }
+         case Long: {
+            os.writeLong((Long)o);
+            break;
+         }
+         case NBTTagCompound: {
+            CompressedStreamTools.write((NBTTagCompound)((NBTTagCompound)o), (DataOutput)os);
+            break;
+         }
+         case Null: {
+            if (withType) break;
             throw new IllegalArgumentException("o has to be non-null without types");
          }
-         break;
-      case Object:
-         throw new IllegalArgumentException("unhandled class: " + o.getClass());
-      case Potion:
-         encode(os, Potion.REGISTRY.getNameForObject((Potion)o), false);
-         break;
-      case ResourceLocation:
-         ResourceLocation resourcelocation = (ResourceLocation)o;
-         os.writeString(resourcelocation.getResourceDomain());
-         os.writeString(resourcelocation.getResourcePath());
-         break;
-      case Short:
-         os.writeShort(((Short)o).shortValue());
-         break;
-      case String:
-         os.writeString((String)o);
-         break;
-      case TileEntity:
-         TileEntity tileentity = (TileEntity)o;
-         encode(os, tileentity.getWorld(), false);
-         encode(os, tileentity.getPos(), false);
-         break;
-      case TupleT2:
-         Tuple.T2<?, ?> t2 = (Tuple.T2)o;
-         encode(os, t2.a, true);
-         encode(os, t2.b, true);
-         break;
-      case TupleT3:
-         Tuple.T3<?, ?, ?> t3 = (Tuple.T3)o;
-         encode(os, t3.a, true);
-         encode(os, t3.b, true);
-         encode(os, t3.c, true);
-         break;
-      case UUID:
-         UUID uuid = (UUID)o;
-         os.writeLong(uuid.getMostSignificantBits());
-         os.writeLong(uuid.getLeastSignificantBits());
-         break;
-      case Vec3:
-         Vec3d vec3d = (Vec3d)o;
-         os.writeDouble(vec3d.x);
-         os.writeDouble(vec3d.y);
-         os.writeDouble(vec3d.z);
-         break;
-      case World:
-         os.writeInt(((World)o).provider.getDimension());
-         break;
-      default:
-         throw new IllegalArgumentException("unhandled type: " + dataencoder$encodedtype);
-      }
-
+         case Object: {
+            throw new IllegalArgumentException("unhandled class: " + o.getClass());
+         }
+         case Potion: {
+            DataEncoder.encode(os, Potion.REGISTRY.getNameForObject(((Potion)o)), false);
+            break;
+         }
+         case ResourceLocation: {
+            ResourceLocation loc = (ResourceLocation)o;
+            os.writeString(loc.getResourceDomain());
+            os.writeString(loc.getResourcePath());
+            break;
+         }
+         case Short: {
+            os.writeShort(((Short)o).shortValue());
+            break;
+         }
+         case String: {
+            os.writeString((String)o);
+            break;
+         }
+         case TileEntity: {
+            TileEntity te = (TileEntity)o;
+            DataEncoder.encode(os, te.getWorld(), false);
+            DataEncoder.encode(os, te.getPos(), false);
+            break;
+         }
+         case TupleT2: {
+            Tuple.T2 t = (Tuple.T2)o;
+            DataEncoder.encode(os, t.a, true);
+            DataEncoder.encode(os, t.b, true);
+            break;
+         }
+         case TupleT3: {
+            Tuple.T3 t = (Tuple.T3)o;
+            DataEncoder.encode(os, t.a, true);
+            DataEncoder.encode(os, t.b, true);
+            DataEncoder.encode(os, t.c, true);
+            break;
+         }
+         case UUID: {
+            UUID uuid = (UUID)o;
+            os.writeLong(uuid.getMostSignificantBits());
+            os.writeLong(uuid.getLeastSignificantBits());
+            break;
+         }
+         case Vec3: {
+            Vec3d v = (Vec3d)o;
+            os.writeDouble(v.x);
+            os.writeDouble(v.y);
+            os.writeDouble(v.z);
+            break;
+         }
+         case World: {
+            os.writeInt(((World)o).provider.getDimension());
+            break;
+         }
+         default: {
+            throw new IllegalArgumentException("unhandled type: " + (Object)((Object)type));
+         }
+      }*/
    }
 
    public static Object decode(IGrowingBuffer is) throws IOException {
       try {
-         return decode(is, typeFromId(is.readUnsignedByte()));
-      } catch (IllegalArgumentException illegalargumentexception) {
-         String s = "An unknown data type was received over multiplayer to be decoded.\nThis could happen due to corrupted data or a bug.";
-         IC2.platform.displayError(illegalargumentexception, s);
+         return DataEncoder.decode(is, DataEncoder.typeFromId(is.readByte()));
+      }
+      catch (IllegalArgumentException e) {
+         String msg = "An unknown data type was received over multiplayer to be decoded.\nThis could happen due to corrupted data or a bug.";
+         IC2.platform.displayError(e, msg, new Object[0]);
          return null;
       }
    }
 
    public static <T> T decode(IGrowingBuffer is, Class<T> clazz) throws IOException {
-      DataEncoder.EncodedType dataencoder$encodedtype = typeFromClass(clazz);
-      if (dataencoder$encodedtype.threadSafe) {
-         return (T)decode(is, dataencoder$encodedtype);
-      } else {
-         throw new IllegalArgumentException("requesting decode for non thread safe type");
+      EncodedType type = DataEncoder.typeFromClass(clazz);
+      if (type.threadSafe) {
+         return (T)DataEncoder.decode(is, type);
       }
+      throw new IllegalArgumentException("requesting decode for non thread safe type");
    }
 
    public static <T extends Enum<T>> T decodeEnum(IGrowingBuffer is, Class<T> clazz) throws IOException {
-      int i = ((Integer)decode(is, DataEncoder.EncodedType.Enum)).intValue();
-      T[] at = clazz.getEnumConstants();
-      return (T)(i >= 0 && i < at.length ? at[i] : null);
+      int ordinal = (Integer)DataEncoder.decode(is, EncodedType.Enum);
+      Enum[] values = (Enum[])clazz.getEnumConstants();
+      return (T)(ordinal >= 0 && ordinal < values.length ? values[ordinal] : null);
    }
 
    public static Object decodeDeferred(GrowingBuffer is, Class<?> clazz) throws IOException {
-      DataEncoder.EncodedType dataencoder$encodedtype = typeFromClass(clazz);
-      return decode(is, dataencoder$encodedtype);
+      EncodedType type = DataEncoder.typeFromClass(clazz);
+      return DataEncoder.decode((IGrowingBuffer)is, type);
    }
 
-   public static Object decode(final IGrowingBuffer is, DataEncoder.EncodedType type) throws IOException {
-      switch(type) {
-      case Addon:
-      case UnSafeAddon:
-         String s = is.readString();
-         final INetworkCustomEncoder inetworkcustomencoder = classToAddonType.get(getClass(s));
-         if (inetworkcustomencoder == null) {
-            throw new IllegalStateException("Cannot decode an object without a decoder! Type was " + s);
-         } else {
-            if (inetworkcustomencoder.isThreadSafe()) {
-               return inetworkcustomencoder.decode(is);
-            }
+   public static Object decode(final IGrowingBuffer is, EncodedType type) throws IOException {
+      switch (type) {
+         case Addon:
+         case UnSafeAddon: {
+            String aimTypeName = is.readString();
+            final INetworkCustomEncoder ince = classToAddonType.get(DataEncoder.getClass(aimTypeName));
+            if (ince == null) {
+               throw new IllegalStateException("Cannot decode an object without a decoder! Type was " + aimTypeName);
+            }
+            if (ince.isThreadSafe()) {
+               return ince.decode(is);
+            }
+            return new IResolvableValue<Object>(){
 
-            return new DataEncoder.IResolvableValue<Object>() {
+               @Override
                public Object get() {
                   try {
-                     return inetworkcustomencoder.decode(is);
-                  } catch (IOException ioexception) {
-                     throw new RuntimeException("Unexpected error", ioexception);
+                     return ince.decode(is);
+                  }
+                  catch (IOException e) {
+                     throw new RuntimeException("Unexpected error", e);
                   }
                }
             };
          }
-      case Array:
-         DataEncoder.EncodedType dataencoder$encodedtype = typeFromId(is.readUnsignedByte());
-         boolean flag1 = is.readBoolean();
-         boolean flag2 = dataencoder$encodedtype == DataEncoder.EncodedType.Enum;
-         Class<?> oclass1 = flag1 ? unbox(dataencoder$encodedtype.cls) : dataencoder$encodedtype.cls;
-         if (oclass1 == null || flag2) {
-            assert dataencoder$encodedtype == DataEncoder.EncodedType.Addon || dataencoder$encodedtype == DataEncoder.EncodedType.UnSafeAddon || flag2;
-
-            oclass1 = getClass(is.readString());
-         }
-
-         final Class<?> oclass = oclass1;
-         final int i2 = is.readVarInt();
-         boolean flag3 = is.readBoolean();
-         boolean flag = !dataencoder$encodedtype.threadSafe;
-         final Object object;
-         if (!flag) {
-            object = Array.newInstance(oclass1, i2);
-         } else {
-            object = new Object[i2];
-         }
-
-         if (!flag3) {
-            if (flag2) {
-               Object[] aobject = oclass1.getEnumConstants();
-
-               assert aobject != null;
-
-               for(int k = 0; k < i2; ++k) {
-                  Array.set(object, k, aobject[((Integer)decode(is, dataencoder$encodedtype)).intValue()]);
+         case Array: {
+            Class<?> component;
+            EncodedType componentType = DataEncoder.typeFromId(is.readUnsignedByte());
+            boolean primitive = is.readBoolean();
+            boolean isEnum = componentType == EncodedType.Enum;
+            Class<?> clazz = component = primitive ? DataEncoder.unbox(componentType.cls) : componentType.cls;
+            if (component == null || isEnum) {
+               assert (componentType == EncodedType.Addon || componentType == EncodedType.UnSafeAddon || isEnum);
+               component = DataEncoder.getClass(is.readString());
+            }
+            final Class<?> componentClass = component;
+            final int len = is.readVarInt();
+            boolean anyTypeMismatch = is.readBoolean();
+            boolean needsResolving = !componentType.threadSafe;
+            Object array = !needsResolving ? Array.newInstance(componentClass, len) : new Object[len];
+            if (!anyTypeMismatch) {
+               if (isEnum) {
+                  Object[] constants = componentClass.getEnumConstants();
+                  assert (constants != null);
+                  for (int i = 0; i < len; ++i) {
+                     Array.set(array, i, constants[(Integer)DataEncoder.decode(is, componentType)]);
+                  }
+               } else {
+                  for (int i = 0; i < len; ++i) {
+                     Array.set(array, i, DataEncoder.decode(is, componentType));
+                  }
                }
             } else {
-               for(int j2 = 0; j2 < i2; ++j2) {
-                  Array.set(object, j2, decode(is, dataencoder$encodedtype));
-               }
-            }
-         } else {
-            for(int k2 = 0; k2 < i2; ++k2) {
-               DataEncoder.EncodedType dataencoder$encodedtype1 = typeFromId(is.readUnsignedByte());
-               if (!dataencoder$encodedtype1.threadSafe && !flag) {
-                  flag = true;
-                  if (oclass != Object.class) {
-                     Object object1 = new Object[i2];
-                     System.arraycopy(object, 0, object1, 0, k2);
-                     object = object1;
-                  }
-               }
-
-               Array.set(object, k2, decode(is, dataencoder$encodedtype1));
-            }
-         }
-
-         if (!flag) {
-            return object;
-         }
-
-         return new DataEncoder.IResolvableValue<Object>() {
-            public Object get() {
-               Object object3 = Array.newInstance(oclass, i2);
-
-               for(int l2 = 0; l2 < i2; ++l2) {
-                  Array.set(object3, l2, DataEncoder.getValue(Array.get(object, l2)));
-               }
-
-               return object3;
-            }
-         };
-      case Block:
-         return Util.getBlock((ResourceLocation)decode(is, DataEncoder.EncodedType.ResourceLocation));
-      case BlockPos:
-         return new BlockPos(is.readInt(), is.readInt(), is.readInt());
-      case Boolean:
-         return is.readBoolean();
-      case Byte:
-         return is.readByte();
-      case Character:
-         return is.readChar();
-      case ChunkPos:
-         return new ChunkPos(is.readInt(), is.readInt());
-      case Collection:
-         final Object object2 = decode(is, DataEncoder.EncodedType.Array);
-         if (object2 instanceof DataEncoder.IResolvableValue) {
-            return new DataEncoder.IResolvableValue<List<Object>>() {
-               public List<Object> get() {
-                  return Arrays.<Object>asList(((DataEncoder.IResolvableValue)object2).get());
-               }
-            };
-         }
-
-         return Arrays.<Object>asList(object2);
-      case Component:
-         return (List<Object>)decode(is, DataEncoder.EncodedType.NBTTagCompound);
-      case CropCard:
-         return Crops.instance.getCropCard(is.readString(), is.readString());
-      case Double:
-         return is.readDouble();
-      case ElectrolyzerRecipe:
-         int i1 = is.readInt();
-         int j1 = is.readInt();
-         int l1 = is.readInt();
-         byte b1 = is.readByte();
-         IElectrolyzerRecipeManager.ElectrolyzerOutput[] aielectrolyzerrecipemanager$electrolyzeroutput = new IElectrolyzerRecipeManager.ElectrolyzerOutput[b1];
-
-         for(byte b0 = 0; b0 < b1; ++b0) {
-            aielectrolyzerrecipemanager$electrolyzeroutput[b0] = new IElectrolyzerRecipeManager.ElectrolyzerOutput(is.readString(), is.readInt(), EnumFacing.getFront(is.readByte()));
-         }
-
-         return new IElectrolyzerRecipeManager.ElectrolyzerRecipe(i1, j1, l1, aielectrolyzerrecipemanager$electrolyzeroutput);
-      case Enchantment:
-         return (List<Object>)Enchantment.REGISTRY.getObject((ResourceLocation)decode(is, DataEncoder.EncodedType.ResourceLocation));
-      case Enum:
-         return is.readVarInt();
-      case Float:
-         return is.readFloat();
-      case Fluid:
-         return FluidRegistry.getFluid(is.readString());
-      case FluidStack:
-         FluidStack fluidstack = new FluidStack((Fluid)decode(is, DataEncoder.EncodedType.Fluid), is.readInt());
-         fluidstack.tag = (NBTTagCompound)decode(is);
-         return fluidstack;
-      case FluidTank:
-         return new FluidTank((FluidStack)decode(is), is.readInt());
-      case GameProfile:
-         return new GameProfile((UUID)decode(is), is.readString());
-      case Integer:
-         return is.readInt();
-      case InvSlot:
-         ItemStack[] aitemstack = (ItemStack[])decode(is, DataEncoder.EncodedType.Array);
-         InvSlot invslot = new InvSlot(aitemstack.length);
-
-         for(int k1 = 0; k1 < aitemstack.length; ++k1) {
-            invslot.put(k1, aitemstack[k1]);
-         }
-
-         return invslot;
-      case Item:
-         return Util.getItem((ResourceLocation)decode(is, DataEncoder.EncodedType.ResourceLocation));
-      case ItemStack:
-         int l = is.readByte();
-         if (l == 0) {
-            return StackUtil.emptyStack;
-         }
-
-         Item item = (Item)decode(is, Item.class);
-         int j = is.readShort();
-         NBTTagCompound nbttagcompound = (NBTTagCompound)decode(is);
-         ItemStack itemstack = new ItemStack(item, l, j);
-         itemstack.setTagCompound(nbttagcompound);
-         return itemstack;
-      case Long:
-         return is.readLong();
-      case NBTTagCompound:
-         return CompressedStreamTools.read(is, NBTSizeTracker.INFINITE);
-      case Null:
-         return null;
-      case Object:
-         return (List<Object>)(new Object());
-      case Potion:
-         return (List<Object>)Potion.REGISTRY.getObject((ResourceLocation)decode(is, DataEncoder.EncodedType.ResourceLocation));
-      case ResourceLocation:
-         return new ResourceLocation(is.readString(), is.readString());
-      case Short:
-         return is.readShort();
-      case String:
-         return is.readString();
-      case TileEntity:
-         final DataEncoder.IResolvableValue<World> iresolvablevalue = (DataEncoder.IResolvableValue)decode(is, DataEncoder.EncodedType.World);
-         final BlockPos blockpos = (BlockPos)decode(is, DataEncoder.EncodedType.BlockPos);
-         return new DataEncoder.IResolvableValue<TileEntity>() {
-            public TileEntity get() {
-               World world = iresolvablevalue.get();
-               return world == null ? null : world.getTileEntity(blockpos);
-            }
-         };
-      case TupleT2:
-         return new Tuple.T2(decode(is), decode(is));
-      case TupleT3:
-         return new Tuple.T3(decode(is), decode(is), decode(is));
-      case UUID:
-         return new UUID(is.readLong(), is.readLong());
-      case Vec3:
-         return new Vec3d(is.readDouble(), is.readDouble(), is.readDouble());
-      case World:
-         final int i = is.readInt();
-         return new DataEncoder.IResolvableValue<World>() {
-            public World get() {
-               return IC2.platform.getWorld(i);
-            }
-         };
-      default:
-         throw new IllegalArgumentException("unhandled type: " + type);
+               for (int i = 0; i < len; ++i) {
+                  EncodedType cType = DataEncoder.typeFromId(is.readUnsignedByte());
+                  if (!cType.threadSafe && !needsResolving) {
+                     needsResolving = true;
+                     if (componentClass != Object.class) {
+                        Object[] newArray = new Object[len];
+                        System.arraycopy(array, 0, newArray, 0, i);
+                        array = newArray;
+                     }
+                  }
+                  Array.set(array, i, DataEncoder.decode(is, cType));
+               }
+            }
+            if (!needsResolving) {
+               return array;
+            }
+            final Object tmpArray = array;
+            return new IResolvableValue<Object>(){
+
+               @Override
+               public Object get() {
+                  Object ret = Array.newInstance(componentClass, len);
+                  for (int i = 0; i < len; ++i) {
+                     Array.set(ret, i, DataEncoder.getValue(Array.get(tmpArray, i)));
+                  }
+                  return ret;
+               }
+            };
+         }
+         case Block: {
+            return Util.getBlock((ResourceLocation)DataEncoder.decode(is, EncodedType.ResourceLocation));
+         }
+         case BlockPos: {
+            return new BlockPos(is.readInt(), is.readInt(), is.readInt());
+         }
+         case Boolean: {
+            return is.readBoolean();
+         }
+         case Byte: {
+            return is.readByte();
+         }
+         case Character: {
+            return Character.valueOf(is.readChar());
+         }
+         case ChunkPos: {
+            return new ChunkPos(is.readInt(), is.readInt());
+         }
+         case Collection: {
+            final Object ret = DataEncoder.decode(is, EncodedType.Array);
+            if (ret instanceof IResolvableValue) {
+               return new IResolvableValue<List<Object>>(){
+
+                  @Override
+                  public List<Object> get() {
+                     return Arrays.asList((Object[])((IResolvableValue)ret).get());
+                  }
+               };
+            }
+            return Arrays.asList((Object[])ret);
+         }
+         case Component: {
+            return DataEncoder.decode(is, EncodedType.NBTTagCompound);
+         }
+         case CropCard: {
+            return Crops.instance.getCropCard(is.readString(), is.readString());
+         }
+         case Double: {
+            return is.readDouble();
+         }
+         case ElectrolyzerRecipe: {
+            int inputAmount = is.readInt();
+            int EUaTick = is.readInt();
+            int ticksNeeded = is.readInt();
+            byte max = is.readByte();
+            IElectrolyzerRecipeManager.ElectrolyzerOutput[] outputs = new IElectrolyzerRecipeManager.ElectrolyzerOutput[max];
+            for (byte i = 0; i < max; i = (byte)(i + 1)) {
+               outputs[i] = new IElectrolyzerRecipeManager.ElectrolyzerOutput(is.readString(), is.readInt(), EnumFacing.getFront((int)is.readByte()));
+            }
+            return new IElectrolyzerRecipeManager.ElectrolyzerRecipe(inputAmount, EUaTick, ticksNeeded, outputs);
+         }
+         case Enchantment: {
+            return Enchantment.REGISTRY.getObject(((ResourceLocation)DataEncoder.decode(is, EncodedType.ResourceLocation)));
+         }
+         case Enum: {
+            return is.readVarInt();
+         }
+         case Float: {
+            return Float.valueOf(is.readFloat());
+         }
+         case Fluid: {
+            return FluidRegistry.getFluid((String)is.readString());
+         }
+         case FluidStack: {
+            FluidStack ret = new FluidStack((Fluid)DataEncoder.decode(is, EncodedType.Fluid), is.readInt());
+            ret.tag = (NBTTagCompound)DataEncoder.decode(is);
+            return ret;
+         }
+         case FluidTank: {
+            return new FluidTank((FluidStack)DataEncoder.decode(is), is.readInt());
+         }
+         case GameProfile: {
+            return new GameProfile((UUID)DataEncoder.decode(is), is.readString());
+         }
+         case Integer: {
+            return is.readInt();
+         }
+         case InvSlot: {
+            ItemStack[] contents = (ItemStack[])DataEncoder.decode(is, EncodedType.Array);
+            InvSlot ret = new InvSlot(contents.length);
+            for (int i = 0; i < contents.length; ++i) {
+               ret.put(i, contents[i]);
+            }
+            return ret;
+         }
+         case Item: {
+            return Util.getItem((ResourceLocation)DataEncoder.decode(is, EncodedType.ResourceLocation));
+         }
+         case ItemStack: {
+            byte size = is.readByte();
+            if (size == 0) {
+               return StackUtil.emptyStack;
+            }
+            Item item = DataEncoder.decode(is, Item.class);
+            short meta = is.readShort();
+            NBTTagCompound nbt = (NBTTagCompound)DataEncoder.decode(is);
+            ItemStack ret = new ItemStack(item, (int)size, (int)meta);
+            ret.setTagCompound(nbt);
+            return ret;
+         }
+         case Long: {
+            return is.readLong();
+         }
+         case NBTTagCompound: {
+            return CompressedStreamTools.read((DataInput)is, (NBTSizeTracker)NBTSizeTracker.INFINITE);
+         }
+         case Null: {
+            return null;
+         }
+         case Object: {
+            return new Object();
+         }
+         case Potion: {
+            return Potion.REGISTRY.getObject(((ResourceLocation)DataEncoder.decode(is, EncodedType.ResourceLocation)));
+         }
+         case ResourceLocation: {
+            return new ResourceLocation(is.readString(), is.readString());
+         }
+         case Short: {
+            return is.readShort();
+         }
+         case String: {
+            return is.readString();
+         }
+         case TileEntity: {
+            final IResolvableValue deferredWorld = (IResolvableValue)DataEncoder.decode(is, EncodedType.World);
+            final BlockPos pos = (BlockPos)DataEncoder.decode(is, EncodedType.BlockPos);
+            return new IResolvableValue<TileEntity>(){
+
+               @Override
+               public TileEntity get() {
+                  World world = (World)deferredWorld.get();
+                  if (world == null) {
+                     return null;
+                  }
+                  return world.getTileEntity(pos);
+               }
+            };
+         }
+         case TupleT2: {
+            return new Tuple.T2<Object, Object>(DataEncoder.decode(is), DataEncoder.decode(is));
+         }
+         case TupleT3: {
+            return new Tuple.T3<Object, Object, Object>(DataEncoder.decode(is), DataEncoder.decode(is), DataEncoder.decode(is));
+         }
+         case UUID: {
+            return new UUID(is.readLong(), is.readLong());
+         }
+         case Vec3: {
+            return new Vec3d(is.readDouble(), is.readDouble(), is.readDouble());
+         }
+         case World: {
+            final int dimensionId = is.readInt();
+            return new IResolvableValue<World>(){
+
+               @Override
+               public World get() {
+                  return IC2.platform.getWorld(dimensionId);
+               }
+            };
+         }
       }
+      throw new IllegalArgumentException("unhandled type: " + (Object)((Object)type));
    }
 
    public static <T> T getValue(Object decoded) {
-      return (T)(decoded instanceof DataEncoder.IResolvableValue ? ((DataEncoder.IResolvableValue)decoded).get() : decoded);
+      if (decoded instanceof IResolvableValue) {
+         return (T) ((IResolvableValue)decoded).get();
+      }
+      return (T)decoded;
    }
 
    public static <T> boolean copyValue(T src, T dst) {
-      if (src != null && dst != null) {
-         if (dst instanceof ItemStack) {
-            ItemStack itemstack = (ItemStack)src;
-            ItemStack itemstack1 = (ItemStack)dst;
-            if (itemstack.getItem() == itemstack1.getItem()) {
-               itemstack1.setCount(itemstack.getCount());
-               StackUtil.setRawMeta(itemstack1, StackUtil.getRawMeta(itemstack));
-               itemstack1.setTagCompound(itemstack.getTagCompound());
-               return true;
-            } else {
-               return false;
-            }
-         } else {
-            if (dst instanceof FluidTank) {
-               FluidTank fluidtank = (FluidTank)src;
-               FluidTank fluidtank1 = (FluidTank)dst;
-               fluidtank1.setFluid(fluidtank.getFluid());
-               fluidtank1.setCapacity(fluidtank.getCapacity());
-            } else if (dst instanceof InvSlot) {
-               InvSlot invslot = (InvSlot)src;
-               InvSlot invslot1 = (InvSlot)dst;
-               if (invslot.size() != invslot1.size()) {
-                  throw new RuntimeException("Can't sync InvSlots with mismatched sizes.");
-               }
-
-               for(int i = 0; i < invslot.size(); ++i) {
-                  if (!copyValue(invslot.get(i), invslot1.get(i))) {
-                     invslot1.put(i, invslot.get(i));
-                  }
-               }
-            } else if (dst instanceof TileEntityComponent) {
-               NBTTagCompound nbttagcompound = (NBTTagCompound)src;
-               ((TileEntityComponent)dst).readFromNbt(nbttagcompound);
-            } else {
-               if (!(dst instanceof Collection)) {
-                  return false;
-               }
-
-               Collection<Object> collection = (Collection)src;
-               Collection<Object> collection1 = (Collection)dst;
-               collection1.clear();
-               collection1.addAll(collection);
-            }
-
+      if (src == null || dst == null) {
+         return false;
+      }
+      if (dst instanceof ItemStack) {
+         ItemStack srcT = (ItemStack)src;
+         ItemStack dstT = (ItemStack)dst;
+         if (srcT.getItem() == dstT.getItem()) {
+            dstT.setCount(srcT.getCount());
+            StackUtil.setRawMeta(dstT, StackUtil.getRawMeta(srcT));
+            dstT.setTagCompound(srcT.getTagCompound());
             return true;
          }
+         return false;
+      }
+      if (dst instanceof FluidTank) {
+         FluidTank srcT = (FluidTank)src;
+         FluidTank dstT = (FluidTank)dst;
+         dstT.setFluid(srcT.getFluid());
+         dstT.setCapacity(srcT.getCapacity());
+      } else if (dst instanceof InvSlot) {
+         InvSlot srcT = (InvSlot)src;
+         InvSlot dstT = (InvSlot)dst;
+         if (srcT.size() != dstT.size()) {
+            throw new RuntimeException("Can't sync InvSlots with mismatched sizes.");
+         }
+         for (int i = 0; i < srcT.size(); ++i) {
+            if (DataEncoder.copyValue(srcT.get(i), dstT.get(i))) continue;
+            dstT.put(i, srcT.get(i));
+         }
+      } else if (dst instanceof TileEntityComponent) {
+         NBTTagCompound nbt = (NBTTagCompound)src;
+         ((TileEntityComponent)dst).readFromNbt(nbt);
+      } else if (dst instanceof Collection) {
+         Collection srcT = (Collection)src;
+         Collection dstT = (Collection)dst;
+         dstT.clear();
+         dstT.addAll(srcT);
       } else {
          return false;
       }
+      return true;
    }
 
    private static Class<?> box(Class<?> clazz) {
       if (clazz == Byte.TYPE) {
          return Byte.class;
-      } else if (clazz == Short.TYPE) {
+      }
+      if (clazz == Short.TYPE) {
          return Short.class;
-      } else if (clazz == Integer.TYPE) {
+      }
+      if (clazz == Integer.TYPE) {
          return Integer.class;
-      } else if (clazz == Long.TYPE) {
+      }
+      if (clazz == Long.TYPE) {
          return Long.class;
-      } else if (clazz == Float.TYPE) {
+      }
+      if (clazz == Float.TYPE) {
          return Float.class;
-      } else if (clazz == Double.TYPE) {
+      }
+      if (clazz == Double.TYPE) {
          return Double.class;
-      } else if (clazz == Boolean.TYPE) {
+      }
+      if (clazz == Boolean.TYPE) {
          return Boolean.class;
-      } else {
-         return clazz == Character.TYPE ? Character.class : clazz;
-      }
+      }
+      if (clazz == Character.TYPE) {
+         return Character.class;
+      }
+      return clazz;
    }
 
    private static Class<?> unbox(Class<?> clazz) {
       if (clazz == Byte.class) {
          return Byte.TYPE;
-      } else if (clazz == Short.class) {
+      }
+      if (clazz == Short.class) {
          return Short.TYPE;
-      } else if (clazz == Integer.class) {
+      }
+      if (clazz == Integer.class) {
          return Integer.TYPE;
-      } else if (clazz == Long.class) {
+      }
+      if (clazz == Long.class) {
          return Long.TYPE;
-      } else if (clazz == Float.class) {
+      }
+      if (clazz == Float.class) {
          return Float.TYPE;
-      } else if (clazz == Double.class) {
+      }
+      if (clazz == Double.class) {
          return Double.TYPE;
-      } else if (clazz == Boolean.class) {
+      }
+      if (clazz == Boolean.class) {
          return Boolean.TYPE;
-      } else {
-         return clazz == Character.class ? Character.TYPE : clazz;
-      }
+      }
+      if (clazz == Character.class) {
+         return Character.TYPE;
+      }
+      return clazz;
    }
 
    private static Class<?> getClass(String type) {
       try {
          return Class.forName(type);
-      } catch (ClassNotFoundException classnotfoundexception) {
-         throw new RuntimeException("Missing type from the class path expected by network: " + type, classnotfoundexception);
+      }
+      catch (ClassNotFoundException e) {
+         throw new RuntimeException("Missing type from the class path expected by network: " + type, e);
       }
    }
 
-   private static int idFromType(DataEncoder.EncodedType type) {
+   private static int idFromType(EncodedType type) {
       return type.ordinal();
    }
 
-   private static DataEncoder.EncodedType typeFromId(int id) {
-      if (id >= 0 && id < DataEncoder.EncodedType.types.length) {
-         return DataEncoder.EncodedType.types[id];
-      } else {
+   private static EncodedType typeFromId(int id) {
+      if (id < 0 || id >= EncodedType.types.length) {
          throw new IllegalArgumentException("invalid type id: " + id);
       }
-   }
-
-   private static DataEncoder.EncodedType typeFromObject(Object o) {
-      return o == null ? DataEncoder.EncodedType.Null : typeFromClass(o.getClass());
-   }
-
-   private static DataEncoder.EncodedType typeFromClass(Class<?> cls) {
+      return EncodedType.types[id];
+   }
+
+   private static EncodedType typeFromObject(Object o) {
+      if (o == null) {
+         return EncodedType.Null;
+      }
+      return DataEncoder.typeFromClass(o.getClass());
+   }
+
+   private static EncodedType typeFromClass(Class<?> cls) {
+      EncodedType ret;
       if (cls == null) {
-         return DataEncoder.EncodedType.Null;
-      } else if (cls.isArray()) {
-         return DataEncoder.EncodedType.Array;
-      } else {
-         if (cls.isPrimitive()) {
-            cls = box(cls);
-         }
-
-         DataEncoder.EncodedType dataencoder$encodedtype = DataEncoder.EncodedType.classToTypeMap.get(cls);
-         if (dataencoder$encodedtype != null) {
-            return dataencoder$encodedtype;
-         } else {
-            dataencoder$encodedtype = classToTypeCache.get(cls);
-            if (dataencoder$encodedtype != null) {
-               return dataencoder$encodedtype;
-            } else {
-               INetworkCustomEncoder inetworkcustomencoder = classToAddonType.get(cls);
-               if (inetworkcustomencoder != null) {
-                  dataencoder$encodedtype = inetworkcustomencoder.isThreadSafe() ? DataEncoder.EncodedType.Addon : DataEncoder.EncodedType.UnSafeAddon;
-                  classToTypeCache.put(cls, dataencoder$encodedtype);
-                  return dataencoder$encodedtype;
-               } else {
-                  for(DataEncoder.EncodedType dataencoder$encodedtype1 : DataEncoder.EncodedType.types) {
-                     if (dataencoder$encodedtype1.cls != null && dataencoder$encodedtype1.cls.isAssignableFrom(cls)) {
-                        classToTypeCache.put(cls, dataencoder$encodedtype1);
-                        return dataencoder$encodedtype1;
-                     }
-                  }
-
-                  throw new IllegalStateException("unmatched " + cls);
-               }
-            }
-         }
-      }
+         return EncodedType.Null;
+      }
+      if (cls.isArray()) {
+         return EncodedType.Array;
+      }
+      if (cls.isPrimitive()) {
+         cls = DataEncoder.box(cls);
+      }
+      if ((ret = EncodedType.classToTypeMap.get(cls)) != null) {
+         return ret;
+      }
+      ret = classToTypeCache.get(cls);
+      if (ret != null) {
+         return ret;
+      }
+      INetworkCustomEncoder ince = classToAddonType.get(cls);
+      if (ince != null) {
+         ret = ince.isThreadSafe() ? EncodedType.Addon : EncodedType.UnSafeAddon;
+         classToTypeCache.put(cls, ret);
+         return ret;
+      }
+      for (EncodedType type : EncodedType.types) {
+         if (type.cls == null || !type.cls.isAssignableFrom(cls)) continue;
+         classToTypeCache.put(cls, type);
+         return type;
+      }
+      throw new IllegalStateException("unmatched " + cls);
    }
 
    public static void addNetworkEncoder(Class<?> typeBeingEncoded, INetworkCustomEncoder customEncoder) {
-      assert typeBeingEncoded != null && customEncoder != null;
-
-      INetworkCustomEncoder inetworkcustomencoder = classToAddonType.put(typeBeingEncoded, customEncoder);
-      if (inetworkcustomencoder != null) {
-         throw new IllegalStateException("Duplicate mapping for class! " + inetworkcustomencoder.getClass().getName() + " and " + customEncoder.getClass().getName() + " both map for " + typeBeingEncoded.getName() + '.');
+      assert (typeBeingEncoded != null && customEncoder != null);
+      INetworkCustomEncoder previous = classToAddonType.put(typeBeingEncoded, customEncoder);
+      if (previous != null) {
+         throw new IllegalStateException("Duplicate mapping for class! " + previous.getClass().getName() + " and " + customEncoder.getClass().getName() + " both map for " + typeBeingEncoded.getName() + '.');
       }
    }
 
    public static enum EncodedType {
-      Null((Class)null),
-      Array((Class)null),
+      Null(null),
+      Array(null),
       Byte(Byte.class),
       Short(Short.class),
       Integer(Integer.class),
@@ -773,15 +832,15 @@
       ElectrolyzerRecipe(IElectrolyzerRecipeManager.ElectrolyzerRecipe.class),
       TupleT2(Tuple.T2.class),
       TupleT3(Tuple.T3.class),
-      Addon((Class)null),
-      UnSafeAddon((Class)null, false),
+      Addon(null),
+      UnSafeAddon(null, false),
       Collection(Collection.class),
       Object(Object.class);
 
       final Class<?> cls;
       final boolean threadSafe;
-      static final DataEncoder.EncodedType[] types = values();
-      static final Map<Class<?>, DataEncoder.EncodedType> classToTypeMap = new IdentityHashMap<Class<?>, DataEncoder.EncodedType>(types.length - 2);
+      static final EncodedType[] types;
+      static final Map<Class<?>, EncodedType> classToTypeMap;
 
       private EncodedType(Class<?> cls) {
          this(cls, true);
@@ -793,19 +852,19 @@
       }
 
       static {
-         for(DataEncoder.EncodedType dataencoder$encodedtype : types) {
-            if (dataencoder$encodedtype.cls != null) {
-               classToTypeMap.put(dataencoder$encodedtype.cls, dataencoder$encodedtype);
-            }
+         types = EncodedType.values();
+         classToTypeMap = new IdentityHashMap(types.length - 2);
+         for (EncodedType type : types) {
+            if (type.cls == null) continue;
+            classToTypeMap.put(type.cls, type);
          }
-
          if (types.length > 255) {
             throw new RuntimeException("too many types");
          }
       }
    }
 
-   private interface IResolvableValue<T> {
-      T get();
+   private static interface IResolvableValue<T> {
+      public T get();
    }
 }
